#!/bin/bash

# =============================================================================
# SCRIPT DE CORRECTION CIBL√â - ERREURS DE COMPILATION DOMAINE MALTS
# =============================================================================
# Bas√© sur l'analyse m√©thodique des erreurs existantes
# Cr√©e UNIQUEMENT les composants manquants identifi√©s dans les erreurs
# =============================================================================

set -e

# Couleurs
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

echo -e "${BLUE}"
echo "üîß =============================================================================="
echo "   CORRECTION CIBL√âE DES ERREURS DE COMPILATION - DOMAINE MALTS"
echo "   Cr√©e uniquement les composants manquants identifi√©s dans l'analyse"
echo "==============================================================================${NC}"

echo -e "${CYAN}üìã PROBL√àMES IDENTIFI√âS ET √Ä CORRIGER :${NC}"
echo "  ‚ùå MaltReadModel manquant"
echo "  ‚ùå PagedResult manquant"
echo "  ‚ùå BaseController et AdminSecuredAction manquants"
echo "  ‚ùå Types Slick (MaltRow, Origin) mal d√©finis"
echo "  ‚ùå Imports manquants"
echo ""

# =============================================================================
# 1. CR√âATION DES READMODELS MANQUANTS
# =============================================================================

echo -e "${GREEN}üì¶ 1. Cr√©ation des ReadModels manquants${NC}"

# Cr√©er les dossiers si n√©cessaire
mkdir -p app/application/queries/public/malts/readmodels
mkdir -p app/application/queries/admin/malts/readmodels

# MaltReadModel - COMPOSANT PRINCIPAL MANQUANT
cat > app/application/queries/public/malts/readmodels/MaltReadModel.scala << 'EOF'
package application.queries.public.malts.readmodels

import domain.malts.model.MaltAggregate
import play.api.libs.json._
import java.time.Instant

/**
 * ReadModel pour les malts - API publique
 * Utilis√© par MaltSearchQueryHandler et autres
 */
case class MaltReadModel(
  id: String,
  name: String,
  maltType: String,
  ebcColor: Double,
  extractionRate: Double,
  diastaticPower: Double,
  originCode: String,
  description: Option[String],
  flavorProfiles: List[String],
  // Propri√©t√©s calcul√©es attendues par MaltsController
  colorName: String,
  extractionCategory: String,
  enzymaticCategory: String,
  maxRecommendedPercent: Option[Double],
  isBaseMalt: Boolean,
  canSelfConvert: Boolean,
  isActive: Boolean,
  createdAt: Instant,
  updatedAt: Instant
)

object MaltReadModel {
  def fromAggregate(malt: MaltAggregate): MaltReadModel = {
    MaltReadModel(
      id = malt.id.toString,
      name = malt.name.value,
      maltType = malt.maltType.name,
      ebcColor = malt.ebcColor.value,
      extractionRate = malt.extractionRate.value,
      diastaticPower = malt.diastaticPower.value,
      originCode = malt.originCode,
      description = malt.description,
      flavorProfiles = malt.flavorProfiles,
      // Propri√©t√©s calcul√©es depuis l'aggregate
      colorName = malt.ebcColor.colorName,
      extractionCategory = malt.extractionRate.extractionCategory,
      enzymaticCategory = malt.diastaticPower.enzymaticCategory,
      maxRecommendedPercent = malt.maxRecommendedPercent,
      isBaseMalt = malt.isBaseMalt,
      canSelfConvert = malt.canSelfConvert,
      isActive = malt.isActive,
      createdAt = malt.createdAt,
      updatedAt = malt.updatedAt
    )
  }
  
  implicit val format: Format[MaltReadModel] = Json.format[MaltReadModel]
}
EOF

# AdminMaltReadModel - Pour l'interface admin
cat > app/application/queries/admin/malts/readmodels/AdminMaltReadModel.scala << 'EOF'
package application.queries.admin.malts.readmodels

import domain.malts.model.MaltAggregate
import play.api.libs.json._
import java.time.Instant

/**
 * ReadModel pour les malts - Interface admin
 * Inclut les informations de credibilit√© et gestion
 */
case class AdminMaltReadModel(
  id: String,
  name: String,
  maltType: String,
  ebcColor: Double,
  extractionRate: Double,
  diastaticPower: Double,
  originCode: String,
  description: Option[String],
  flavorProfiles: List[String],
  source: String,
  isActive: Boolean,
  credibilityScore: Double,
  createdAt: Instant,
  updatedAt: Instant,
  version: Long
)

object AdminMaltReadModel {
  def fromAggregate(malt: MaltAggregate): AdminMaltReadModel = {
    AdminMaltReadModel(
      id = malt.id.toString,
      name = malt.name.value,
      maltType = malt.maltType.name,
      ebcColor = malt.ebcColor.value,
      extractionRate = malt.extractionRate.value,
      diastaticPower = malt.diastaticPower.value,
      originCode = malt.originCode,
      description = malt.description,
      flavorProfiles = malt.flavorProfiles,
      source = malt.source.name,
      isActive = malt.isActive,
      credibilityScore = malt.credibilityScore,
      createdAt = malt.createdAt,
      updatedAt = malt.updatedAt,
      version = malt.version
    )
  }
  
  implicit val format: Format[AdminMaltReadModel] = Json.format[AdminMaltReadModel]
}
EOF

# AdminMaltDetailResult - Attendu par AdminMaltsController
cat > app/application/queries/admin/malts/readmodels/AdminMaltDetailResult.scala << 'EOF'
package application.queries.admin.malts.readmodels

import play.api.libs.json._

/**
 * R√©sultat d√©taill√© pour l'admin avec substituts et compatibilit√©s
 */
case class AdminMaltDetailResult(
  malt: AdminMaltReadModel,
  substitutes: List[AdminSubstituteReadModel] = List.empty,
  compatibilities: List[BeerStyleCompatibility] = List.empty,
  statistics: Option[MaltUsageStatistics] = None,
  qualityAnalysis: Option[QualityAnalysis] = None
)

case class AdminSubstituteReadModel(
  id: String,
  name: String,
  compatibilityScore: Double,
  notes: String
)

case class BeerStyleCompatibility(
  styleId: String,
  styleName: String,
  compatibilityScore: Double,
  usageNotes: String
)

case class MaltUsageStatistics(
  totalUsage: Long,
  popularityScore: Double,
  averageUsagePercentage: Double,
  topBeerStyles: List[String]
)

case class QualityAnalysis(
  overallScore: Double,
  consistencyRating: String,
  dataCompleteness: Double,
  recommendedActions: List[String]
)

object AdminMaltDetailResult {
  implicit val substituteFormat: Format[AdminSubstituteReadModel] = Json.format[AdminSubstituteReadModel]
  implicit val compatibilityFormat: Format[BeerStyleCompatibility] = Json.format[BeerStyleCompatibility]
  implicit val statisticsFormat: Format[MaltUsageStatistics] = Json.format[MaltUsageStatistics]
  implicit val qualityFormat: Format[QualityAnalysis] = Json.format[QualityAnalysis]
  implicit val format: Format[AdminMaltDetailResult] = Json.format[AdminMaltDetailResult]
}
EOF

# MaltDetailResult - Pour l'API publique
mkdir -p app/application/queries/public/malts/readmodels
cat > app/application/queries/public/malts/readmodels/MaltDetailResult.scala << 'EOF'
package application.queries.public.malts.readmodels

import play.api.libs.json._

/**
 * R√©sultat d√©taill√© pour l'API publique
 */
case class MaltDetailResult(
  malt: MaltReadModel,
  substitutes: List[SubstituteReadModel] = List.empty,
  compatibleBeerStyles: List[String] = List.empty
)

case class SubstituteReadModel(
  id: String,
  name: String,
  compatibilityScore: Double
)

object MaltDetailResult {
  implicit val substituteFormat: Format[SubstituteReadModel] = Json.format[SubstituteReadModel]
  implicit val format: Format[MaltDetailResult] = Json.format[MaltDetailResult]
}
EOF

echo "‚úÖ ReadModels cr√©√©s"

# =============================================================================
# 2. CR√âATION DU TYPE PAGEDRESULT MANQUANT
# =============================================================================

echo -e "${GREEN}üì¶ 2. Cr√©ation du type PagedResult${NC}"

# PagedResult - Manquant dans domain.malts.repositories
mkdir -p app/domain/malts/repositories
cat > app/domain/malts/repositories/PagedResult.scala << 'EOF'
package domain.malts.repositories

/**
 * Type PagedResult utilis√© par MaltSearchQueryHandler
 * R√©sultat pagin√© g√©n√©rique
 */
case class PagedResult[T](
  items: List[T],
  currentPage: Int,
  pageSize: Int,
  totalCount: Long,
  hasNext: Boolean
)
EOF

echo "‚úÖ PagedResult cr√©√©"

# =============================================================================
# 3. CR√âATION DES COMPOSANTS HTTP MANQUANTS
# =============================================================================

echo -e "${GREEN}üì¶ 3. Cr√©ation des composants HTTP manquants${NC}"

# BaseController - Manquant dans interfaces.http.common
mkdir -p app/interfaces/http/common
cat > app/interfaces/http/common/BaseController.scala << 'EOF'
package interfaces.http.common

import play.api.mvc._
import play.api.libs.json._
import domain.common.DomainError

/**
 * Contr√¥leur de base avec m√©thodes communes
 * Utilis√© par MaltsController et AdminMaltsController
 */
abstract class BaseController(cc: ControllerComponents) extends AbstractController(cc) {

  /**
   * Gestion standardis√©e des erreurs de domaine
   */
  protected def handleDomainError(error: DomainError): Result = error match {
    case DomainError.NotFound(message, _) => 
      NotFound(Json.obj("error" -> "not_found", "message" -> message))
    case DomainError.BusinessRule(message, code) => 
      BadRequest(Json.obj("error" -> "business_rule", "code" -> code, "message" -> message))
    case DomainError.Validation(message, field) => 
      BadRequest(Json.obj("error" -> "validation", "field" -> field, "message" -> message))
    case _ => 
      InternalServerError(Json.obj("error" -> "internal_error", "message" -> "Une erreur interne s'est produite"))
  }

  /**
   * R√©ponse de succ√®s standardis√©e
   */
  protected def successResponse[T](data: T)(implicit writes: Writes[T]): Result = {
    Ok(Json.obj("success" -> true, "data" -> data))
  }

  /**
   * R√©ponse d'erreur standardis√©e
   */
  protected def errorResponse(message: String, errorType: String = "error"): Result = {
    BadRequest(Json.obj("success" -> false, "error" -> errorType, "message" -> message))
  }
}
EOF

# AdminSecuredAction - Manquant dans interfaces.actions
mkdir -p app/interfaces/actions
cat > app/interfaces/actions/AdminSecuredAction.scala << 'EOF'
package interfaces.actions

import domain.admin.model.AdminAggregate
import domain.admin.repositories.AdminReadRepository
import javax.inject._
import play.api.mvc._
import play.api.libs.json.Json
import scala.concurrent.{ExecutionContext, Future}

/**
 * Requ√™te s√©curis√©e avec administrateur authentifi√©
 */
case class AdminRequest[A](admin: AdminAggregate, request: Request[A]) extends WrappedRequest[A](request)

/**
 * Action s√©curis√©e pour les administrateurs
 * Utilis√©e par AdminMaltsController
 */
@Singleton
class AdminSecuredAction @Inject()(
  parser: BodyParsers.Default,
  adminRepo: AdminReadRepository
)(implicit ec: ExecutionContext) extends ActionBuilder[AdminRequest, AnyContent] {

  override def parser: BodyParser[AnyContent] = parser.default
  override protected def executionContext: ExecutionContext = ec

  override def invokeBlock[A](request: Request[A], block: AdminRequest[A] => Future[Result]): Future[Result] = {
    extractAdminFromSession(request).flatMap {
      case Some(admin) if admin.isActive =>
        block(AdminRequest(admin, request))
      case Some(_) =>
        Future.successful(Results.Forbidden(Json.obj("error" -> "account_disabled")))
      case None =>
        Future.successful(Results.Unauthorized(Json.obj("error" -> "authentication_required")))
    }
  }

  private def extractAdminFromSession[A](request: Request[A]): Future[Option[AdminAggregate]] = {
    request.session.get("admin_id") match {
      case Some(adminId) => 
        // Simplification pour compilation - √† am√©liorer avec le vrai repository
        Future.successful(None)
      case None => 
        Future.successful(None)
    }
  }
}
EOF

echo "‚úÖ Composants HTTP cr√©√©s"

# =============================================================================
# 4. CORRECTION DES IMPORTS DANS SLICK TABLES
# =============================================================================

echo -e "${GREEN}üì¶ 4. Correction des types Slick${NC}"

# Ajout du type Origin manquant dans MaltTables
# On le d√©finit directement dans le fichier pour √©viter les d√©pendances complexes
cat > app/infrastructure/persistence/slick/tables/MaltTablesAdditions.scala << 'EOF'
package infrastructure.persistence.slick.tables

/**
 * Types additionnels pour corriger les erreurs de compilation MaltTables
 */

// Type Origin manquant dans MaltTables.scala
case class Origin(
  code: String,
  name: String,
  region: Option[String] = None
)

// MaltRow pour SlickMaltReadRepository
case class MaltRow(
  id: String,
  name: String,
  maltType: String,
  ebcColor: Double,
  extractionRate: Double,
  diastaticPower: Double,
  originCode: String,
  description: Option[String],
  flavorProfiles: Option[List[String]],
  source: String,
  isActive: Boolean,
  credibilityScore: Double,
  createdAt: java.time.Instant,
  updatedAt: java.time.Instant,
  version: Long
)
EOF

echo "‚úÖ Types Slick ajout√©s"

# =============================================================================
# 5. CORRECTION DES HANDLERS EXISTANTS
# =============================================================================

echo -e "${GREEN}üì¶ 5. Mise √† jour des imports dans les handlers${NC}"

# Cr√©er un fichier de package object pour faciliter les imports
cat > app/application/queries/public/malts/package.scala << 'EOF'
package application.queries.public

/**
 * Package object pour faciliter les imports des malts
 */
package object malts {
  // Import des ReadModels
  import readmodels._
  
  // Types d'exports pour √©viter les imports complexes
  type MaltReadModel = readmodels.MaltReadModel
  type MaltDetailResult = readmodels.MaltDetailResult
}
EOF

# =============================================================================
# 6. AJOUT DES IMPORTS MANQUANTS EN DOMAIN
# =============================================================================

echo -e "${GREEN}üì¶ 6. Ajout des imports de base du domaine${NC}"

# Ajout de UpdateMaltCommandHandler manquant
mkdir -p app/application/commands/admin/malts/handlers
cat > app/application/commands/admin/malts/handlers/UpdateMaltCommandHandler.scala << 'EOF'
package application.commands.admin.malts.handlers

import domain.common.DomainError
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

/**
 * Handler pour UpdateMaltCommand - Impl√©mentation basique pour compilation
 */
@Singleton
class UpdateMaltCommandHandler @Inject()(
  // repositories seront inject√©s plus tard
)(implicit ec: ExecutionContext) {

  // Impl√©mentation temporaire pour permettre la compilation
  def handle(command: Any): Future[Either[DomainError, String]] = {
    Future.successful(Right("updated-malt-id"))
  }
}
EOF

echo "‚úÖ Handlers de base ajout√©s"

# =============================================================================
# RAPPORT FINAL
# =============================================================================

echo ""
echo -e "${BLUE}üìä =============================================================================="
echo "   RAPPORT DE CORRECTION TERMIN√â"
echo "==============================================================================${NC}"

echo -e "${GREEN}‚úÖ COMPOSANTS CR√â√âS :${NC}"
echo "   üì¶ MaltReadModel et AdminMaltReadModel"
echo "   üì¶ MaltDetailResult et AdminMaltDetailResult"
echo "   üì¶ PagedResult dans domain.malts.repositories"
echo "   üì¶ BaseController dans interfaces.http.common"
echo "   üì¶ AdminSecuredAction dans interfaces.actions"
echo "   üì¶ Types Slick (MaltRow, Origin)"
echo "   üì¶ Package objects pour faciliter les imports"
echo "   üì¶ UpdateMaltCommandHandler basique"

echo ""
echo -e "${CYAN}üéØ PROCHAINES √âTAPES :${NC}"
echo "   1. Tester la compilation : ${YELLOW}sbt compile${NC}"
echo "   2. Corriger les imports restants si n√©cessaire"
echo "   3. Impl√©menter la logique m√©tier dans les handlers"
echo "   4. Ajouter les tests unitaires"

echo ""
echo -e "${GREEN}üöÄ La plupart des erreurs de compilation devraient √™tre r√©solues !${NC}"
