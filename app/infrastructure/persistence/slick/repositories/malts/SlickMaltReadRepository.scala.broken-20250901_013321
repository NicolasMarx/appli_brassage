package infrastructure.persistence.slick.repositories.malts

import javax.inject._
import play.api.db.slick.{DatabaseConfigProvider, HasDatabaseConfigProvider}
import slick.jdbc.JdbcProfile
import scala.concurrent.{ExecutionContext, Future}
import java.time.Instant
import java.util.UUID
import scala.util.{Try, Success, Failure}

import domain.malts.model._
import domain.malts.repositories.MaltReadRepository
import domain.shared.NonEmptyString

@Singleton
class SlickMaltReadRepository @Inject()(
  protected val dbConfigProvider: DatabaseConfigProvider
)(implicit ec: ExecutionContext)
  extends MaltReadRepository
    with HasDatabaseConfigProvider[JdbcProfile] {

  import profile.api._

  // ===============================
  // D√âFINITION DES TABLES ET ROWS
  // ===============================

  case class MaltRow(
    id: UUID,
    name: String,
    maltType: String,
    ebcColor: Double,
    extractionRate: Double,
    diastaticPower: Double,
    originCode: String,
    description: Option[String],
    flavorProfiles: Option[String],
    source: String,
    isActive: Boolean,
    credibilityScore: Double,
    createdAt: Instant,
    updatedAt: Instant,
    version: Long
  )

  class MaltsTable(tag: Tag) extends Table[MaltRow](tag, "malts") {
    def id = column[UUID]("id", O.PrimaryKey)
    def name = column[String]("name")
    def maltType = column[String]("malt_type")
    def ebcColor = column[Double]("ebc_color")
    def extractionRate = column[Double]("extraction_rate")
    def diastaticPower = column[Double]("diastatic_power")
    def originCode = column[String]("origin_code")
    def description = column[Option[String]]("description")
    def flavorProfiles = column[Option[String]]("flavor_profiles")
    def source = column[String]("source")
    def isActive = column[Boolean]("is_active")
    def credibilityScore = column[Double]("credibility_score")
    def createdAt = column[Instant]("created_at")
    def updatedAt = column[Instant]("updated_at")
    def version = column[Long]("version")

    def * = (id, name, maltType, ebcColor, extractionRate, diastaticPower, 
             originCode, description, flavorProfiles, source, isActive, 
             credibilityScore, createdAt, updatedAt, version).mapTo[MaltRow]
  }

  val malts = TableQuery[MaltsTable]

  // ===============================
  // HELPER FUNCTIONS
  // ===============================

  private def parseFlavorProfiles(flavorProfilesString: Option[String]): List[String] = {
    flavorProfilesString match {
      case None => List.empty
      case Some(str) if str.trim.isEmpty => List.empty
      case Some(str) =>
        if (str.trim.startsWith("[") && str.trim.endsWith("]")) {
          try {
            play.api.libs.json.Json.parse(str).as[List[String]]
          } catch {
            case _: Exception => 
              str.replace("[", "").replace("]", "").replace("\"", "").split(",").map(_.trim).filter(_.nonEmpty).toList
          }
        } else {
          str.split(",").map(_.trim).filter(_.nonEmpty).toList
        }
    }
  }

  private def rowToAggregateSafe(row: MaltRow): Try[MaltAggregate] = Try {
    println(s"üîç DEBUG: Conversion malt '${row.name}' (ID: ${row.id})")
    
    val maltId = MaltId(row.id)
    val name = NonEmptyString.create(row.name).getOrElse(NonEmptyString.unsafe(row.name))
    val maltType = MaltType.fromName(row.maltType).getOrElse(MaltType.unsafe(row.maltType))
    val source = MaltSource.fromName(row.source).getOrElse(MaltSource.unsafe(row.source))
    val ebcColor = EBCColor(row.ebcColor).getOrElse(EBCColor.unsafe(row.ebcColor))
    val extractionRate = ExtractionRate(row.extractionRate).getOrElse(ExtractionRate.unsafe(row.extractionRate))
    val diastaticPower = DiastaticPower(row.diastaticPower).getOrElse(DiastaticPower.unsafe(row.diastaticPower))
    val flavorProfiles = parseFlavorProfiles(row.flavorProfiles)
    
    println(s"   ‚úÖ Conversion r√©ussie: ${row.name}")
    
    MaltAggregate(
      id = maltId,
      name = name,
      maltType = maltType,
      ebcColor = ebcColor,
      extractionRate = extractionRate,
      diastaticPower = diastaticPower,
      originCode = row.originCode,
      description = row.description,
      flavorProfiles = flavorProfiles,
      source = source,
      isActive = row.isActive,
      credibilityScore = row.credibilityScore,
      createdAt = row.createdAt,
      updatedAt = row.updatedAt,
      version = row.version
    )
  }

  private def rowToAggregateUnsafe(row: MaltRow): MaltAggregate = {
    println(s"üö® FALLBACK: Conversion unsafe pour '${row.name}'")
    
    MaltAggregate(
      id = MaltId(row.id),
      name = NonEmptyString.unsafe(row.name),
      maltType = MaltType.unsafe(row.maltType),
      ebcColor = EBCColor.unsafe(row.ebcColor),
      extractionRate = ExtractionRate.unsafe(row.extractionRate),
      diastaticPower = DiastaticPower.unsafe(row.diastaticPower),
      originCode = row.originCode,
      description = row.description,
      flavorProfiles = parseFlavorProfiles(row.flavorProfiles),
      source = MaltSource.unsafe(row.source),
      isActive = row.isActive,
      credibilityScore = row.credibilityScore,
      createdAt = row.createdAt,
      updatedAt = row.updatedAt,
      version = row.version
    )
  }

  private def rowToAggregate(row: MaltRow): MaltAggregate = {
    rowToAggregateSafe(row) match {
      case Success(aggregate) => aggregate
      case Failure(ex) => 
        println(s"‚ùå √âchec conversion safe pour '${row.name}': ${ex.getMessage}")
        rowToAggregateUnsafe(row)
    }
  }

  // ===============================
  // IMPL√âMENTATION DES M√âTHODES
  // ===============================

  override def findById(id: MaltId): Future[Option[MaltAggregate]] = {
    println(s"üîç Recherche malt par ID: ${id}")
    
    db.run(malts.filter(_.id === id.value).result.headOption).map { rowOpt =>
      val result = rowOpt.map(rowToAggregate)
      println(s"   R√©sultat: ${result.map(_.name.value).getOrElse("Non trouv√©")}")
      result
    }.recover {
      case ex =>
        println(s"‚ùå Erreur recherche par ID ${id}: ${ex.getMessage}")
        None
    }
  }

  override def findAll(page: Int, pageSize: Int, activeOnly: Boolean = false): Future[List[MaltAggregate]] = {
    println(s"üîç Recherche tous les malts (page $page, taille $pageSize, actifs: $activeOnly)")
    
    val offset = page * pageSize
    val baseQuery = malts.sortBy(_.name)
    val query = if (activeOnly) {
      baseQuery.filter(_.isActive === true).drop(offset).take(pageSize)
    } else {
      baseQuery.drop(offset).take(pageSize)
    }

    db.run(query.result).map { rows =>
      println(s"   üìã R√©cup√©r√© ${rows.length} lignes de la DB")
      val aggregates = rows.map(rowToAggregate).toList
      println(s"   ‚úÖ Converti ${aggregates.length} agr√©gats")
      aggregates
    }.recover {
      case ex =>
        println(s"‚ùå Erreur findAll: ${ex.getMessage}")
        List.empty[MaltAggregate]
    }
  }

  override def count(activeOnly: Boolean = false): Future[Long] = {
    println(s"üìä Comptage des malts (actifs: $activeOnly)")
    
    val query = if (activeOnly) {
      malts.filter(_.isActive === true).length
    } else {
      malts.length
    }
    
    db.run(query.result).map { count =>
      val longCount = count.toLong
      println(s"   Total malts: $longCount")
      longCount
    }.recover {
      case ex =>
        println(s"‚ùå Erreur comptage: ${ex.getMessage}")
        0L
    }
  }

  def findByType(maltType: MaltType): Future[List[MaltAggregate]] = {
    println(s"üîç Recherche malts par type: ${maltType.name}")
    
    db.run(malts.filter(_.maltType === maltType.name).result).map { rows =>
      val aggregates = rows.map(rowToAggregate).toList
      println(s"   Trouv√© ${aggregates.length} malts de type ${maltType.name}")
      aggregates
    }.recover {
      case ex =>
        println(s"‚ùå Erreur recherche par type: ${ex.getMessage}")
        List.empty[MaltAggregate]
    }
  }

  def findActive(): Future[List[MaltAggregate]] = {
    findAll(0, 1000, activeOnly = true)
  }

  override def search(query: String, page: Int = 0, pageSize: Int = 20): Future[List[MaltAggregate]] = {
    println(s"üîç Recherche malts avec terme: '$query'")
    
    val searchTerm = s"%${query.toLowerCase}%"
    val offset = page * pageSize
    
    val searchQuery = malts
      .filter(row => 
        row.name.toLowerCase.like(searchTerm) || 
        row.description.toLowerCase.like(searchTerm) ||
        row.maltType.toLowerCase.like(searchTerm)
      )
      .sortBy(_.name)
      .drop(offset)
      .take(pageSize)

    db.run(searchQuery.result).map { rows =>
      val aggregates = rows.map(rowToAggregate).toList
      println(s"   Trouv√© ${aggregates.length} malts pour '$query'")
      aggregates
    }.recover {
      case ex =>
        println(s"‚ùå Erreur recherche: ${ex.getMessage}")
        List.empty[MaltAggregate]
    }
  }
}

  // ===============================
  // NOUVELLES M√âTHODES REQUISES
  // ===============================

  override def existsByName(name: NonEmptyString): Future[Boolean] = {
    println(s"üîç V√©rification existence malt: ${name.value}")
    
    db.run(malts.filter(_.name.toLowerCase === name.value.toLowerCase).exists.result).map { exists =>
      println(s"   Malt '${name.value}' existe: $exists")
      exists
    }.recover {
      case ex =>
        println(s"‚ùå Erreur v√©rification existence: ${ex.getMessage}")
        false
    }
  }

  override def findByFilters(
    maltType: Option[String] = None,
    minEBC: Option[Double] = None,
    maxEBC: Option[Double] = None,
    originCode: Option[String] = None,
    status: Option[String] = None,
    searchTerm: Option[String] = None,
    flavorProfiles: List[String] = List.empty,
    page: Int = 0,
    pageSize: Int = 20
  ): Future[List[MaltAggregate]] = {
    println(s"üîç Recherche avec filtres: type=$maltType, ebc=$minEBC-$maxEBC, search=$searchTerm")
    
    val offset = page * pageSize
    
    // Construction de la query avec filtres
    var query = malts.sortBy(_.name)
    
    // Filtre par type
    maltType.foreach { mt =>
      query = query.filter(_.maltType === mt)
    }
    
    // Filtre par couleur EBC
    minEBC.foreach { min =>
      query = query.filter(_.ebcColor >= min)
    }
    maxEBC.foreach { max =>
      query = query.filter(_.ebcColor <= max)
    }
    
    // Filtre par origine
    originCode.foreach { origin =>
      query = query.filter(_.originCode === origin)
    }
    
    // Filtre par statut (active/inactive)
    status.foreach { s =>
      val isActive = s.toUpperCase == "ACTIVE"
      query = query.filter(_.isActive === isActive)
    }
    
    // Recherche textuelle
    searchTerm.foreach { term =>
      val searchPattern = s"%${term.toLowerCase}%"
      query = query.filter(row => 
        row.name.toLowerCase.like(searchPattern) ||
        row.description.toLowerCase.like(searchPattern)
      )
    }
    
    // Application pagination
    val finalQuery = query.drop(offset).take(pageSize)

    db.run(finalQuery.result).map { rows =>
      val aggregates = rows.map(rowToAggregate).toList
      println(s"   Trouv√© ${aggregates.length} malts avec filtres")
      aggregates
    }.recover {
      case ex =>
        println(s"‚ùå Erreur recherche avec filtres: ${ex.getMessage}")
        List.empty[MaltAggregate]
    }
  }
}
