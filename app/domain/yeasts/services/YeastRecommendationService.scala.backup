package domain.yeasts.services

import domain.yeasts.model._
import domain.yeasts.repositories.YeastReadRepository
import javax.inject.{Inject, Singleton}
import scala.concurrent.{ExecutionContext, Future}

/**
 * Service de recommandations intelligentes pour les levures
 * Algorithmes de suggestion basés sur les caractéristiques de brassage
 */
@Singleton
class YeastRecommendationService @Inject()(
  yeastReadRepository: YeastReadRepository
)(implicit ec: ExecutionContext) {

  /**
   * Recommandations pour débutants
   */
  def getBeginnerFriendlyYeasts(maxResults: Int = 5): Future[List[RecommendedYeast]] = {
    val beginnerCriteria = YeastFilter(
      status = List(YeastStatus.Active)
    ).copy(size = 50)
    
    yeastReadRepository.findByFilter(beginnerCriteria).map { result =>
      result.items
        .filter(isBeginnerFriendly)
        .map(yeast => RecommendedYeast(
          yeast = yeast,
          score = calculateBeginnerScore(yeast),
          reason = generateBeginnerReason(yeast),
          tips = generateBeginnerTips(yeast)
        ))
        .sortBy(-_.score)
        .take(maxResults)
    }
  }

  /**
   * Recommandations par saison
   */
  def getSeasonalRecommendations(season: Season, maxResults: Int = 8): Future[List[RecommendedYeast]] = {
    val seasonalTypes = getSeasonalYeastTypes(season)
    
    Future.sequence(seasonalTypes.map { yeastType =>
      val filter = YeastFilter(
        yeastType = Some(yeastType),
        status = List(YeastStatus.Active)
      ).copy(size = 20)
      
      yeastReadRepository.findByFilter(filter)
    }).map { results =>
      results.flatMap(_.items)
        .map(yeast => RecommendedYeast(
          yeast = yeast,
          score = calculateSeasonalScore(yeast, season),
          reason = generateSeasonalReason(yeast, season),
          tips = generateSeasonalTips(yeast, season)
        ))
        .sortBy(-_.score)
        .take(maxResults)
    }
  }

  /**
   * Recommandations pour expérimentateurs
   */
  def getExperimentalYeasts(maxResults: Int = 6): Future[List[RecommendedYeast]] = {
    val experimentalCriteria = YeastFilter(
      status = List(YeastStatus.Active)
    ).copy(size = 50)
    
    yeastReadRepository.findByFilter(experimentalCriteria).map { result =>
      result.items
        .filter(isExperimental)
        .map(yeast => RecommendedYeast(
          yeast = yeast,
          score = calculateExperimentalScore(yeast),
          reason = generateExperimentalReason(yeast),
          tips = generateExperimentalTips(yeast)
        ))
        .sortBy(-_.score)
        .take(maxResults)
    }
  }

  /**
   * Recommandations par profil aromatique désiré
   */
  def getByAromaProfile(
    desiredAromas: List[String], 
    maxResults: Int = 10
  ): Future[List[RecommendedYeast]] = {
    val filter = YeastFilter(
      characteristics = desiredAromas,
      status = List(YeastStatus.Active)
    ).copy(size = 100)
    
    yeastReadRepository.findByFilter(filter).map { result =>
      result.items
        .map(yeast => RecommendedYeast(
          yeast = yeast,
          score = calculateAromaMatchScore(yeast, desiredAromas),
          reason = generateAromaReason(yeast, desiredAromas),
          tips = generateAromaTips(yeast)
        ))
        .filter(_.score > 0.3) // Seuil minimum de pertinence
        .sortBy(-_.score)
        .take(maxResults)
    }
  }

  /**
   * Alternatives à une levure donnée
   */
  def findAlternatives(
    originalYeastId: YeastId, 
    reason: AlternativeReason = AlternativeReason.Unavailable,
    maxResults: Int = 5
  ): Future[List[RecommendedYeast]] = {
    
    yeastReadRepository.findById(originalYeastId).flatMap {
      case Some(original) =>
        val similarityFilter = YeastFilter(
          yeastType = Some(original.yeastType),
          status = List(YeastStatus.Active)
        ).copy(size = 50)
        
        yeastReadRepository.findByFilter(similarityFilter).map { result =>
          result.items
            .filter(_.id != originalYeastId)
            .map(yeast => RecommendedYeast(
              yeast = yeast,
              score = calculateSimilarityScore(original, yeast),
              reason = generateAlternativeReason(yeast, original, reason),
              tips = generateAlternativeTips(yeast, original)
            ))
            .sortBy(-_.score)
            .take(maxResults)
        }
        
      case None => Future.successful(List.empty)
    }
  }

  /**
   * Recommandations pour batch de test
   */
  def getTestBatchRecommendations(
    baseRecipe: TestRecipeParams,
    maxResults: Int = 3
  ): Future[List[RecommendedYeast]] = {
    
    val compatibleTypes = YeastType.recommendedForBeerStyle(baseRecipe.style)
    val typeFilters = compatibleTypes.map(t => YeastFilter(yeastType = Some(t)))
    
    Future.sequence(typeFilters.map(filter =>
      yeastReadRepository.findByFilter(filter.copy(size = 20))
    )).map { results =>
      results.flatMap(_.items)
        .filter(yeast => 
          yeast.temperature.contains(baseRecipe.fermentationTemp) &&
          yeast.alcoholTolerance.canFerment(baseRecipe.expectedAbv)
        )
        .map(yeast => RecommendedYeast(
          yeast = yeast,
          score = calculateTestBatchScore(yeast, baseRecipe),
          reason = generateTestBatchReason(yeast, baseRecipe),
          tips = generateTestBatchTips(yeast, baseRecipe)
        ))
        .sortBy(-_.score)
        .take(maxResults)
    }
  }

  // ==========================================================================
  // MÉTHODES PRIVÉES - SCORING ET CLASSIFICATION
  // ==========================================================================

  private def isBeginnerFriendly(yeast: YeastAggregate): Boolean = {
    val hasSuitableFlocculation = yeast.flocculation match {
      case FlocculationLevel.Medium | FlocculationLevel.MediumHigh | FlocculationLevel.High => true
      case _ => false
    }

    hasSuitableFlocculation &&
      yeast.temperature.range <= 6 && // Plage de température pas trop large
      yeast.characteristics.isClean // Profil neutre plus facile
  }

  private def calculateBeginnerScore(yeast: YeastAggregate): Double = {
    var score = 0.0
    
    // Bonus floculation élevée (plus facile à clarifier)
    yeast.flocculation match {
      case FlocculationLevel.High => score += 0.3
      case FlocculationLevel.MediumHigh => score += 0.25
      case FlocculationLevel.Medium => score += 0.2
      case _ => score += 0.0
    }
    
    // Bonus profil propre
    if (yeast.characteristics.isClean) score += 0.25
    
    // Bonus plage température raisonnable
    if (yeast.temperature.range <= 4) score += 0.2
    
    // Bonus atténuation prévisible
    if (yeast.attenuation.range <= 8) score += 0.15
    
    // Bonus laboratoires reconnus pour débutants
    yeast.laboratory match {
      case YeastLaboratory.Fermentis | YeastLaboratory.Lallemand => score += 0.1
      case _ => score += 0.05
    }
    
    score
  }

  private def isExperimental(yeast: YeastAggregate): Boolean = {
    yeast.yeastType match {
      case YeastType.Wild | YeastType.Sour | YeastType.Kveik => true
      case YeastType.Saison if yeast.temperature.max >= 30 => true
      case _ => yeast.characteristics.allCharacteristics.exists(c => 
        c.toLowerCase.matches(".*(wild|brett|funk|barnyard|horse).*")
      )
    }
  }

  private def calculateExperimentalScore(yeast: YeastAggregate): Double = {
    var score = 0.0
    
    yeast.yeastType match {
      case YeastType.Wild => score += 0.4
      case YeastType.Sour => score += 0.35
      case YeastType.Kveik => score += 0.3
      case YeastType.Saison if yeast.temperature.max >= 30 => score += 0.25
      case _ => score += 0.0
    }
    
    // Bonus caractéristiques uniques
    val uniqueChars = List("funky", "horse", "barnyard", "brett", "wild", "complex")
    val matchingChars = yeast.characteristics.allCharacteristics
      .count(c => uniqueChars.exists(u => c.toLowerCase.contains(u)))
    score += matchingChars * 0.1
    
    score
  }

  private def getSeasonalYeastTypes(season: Season): List[YeastType] = {
    season match {
      case Season.Spring => List(YeastType.Saison, YeastType.Wheat, YeastType.Ale)
      case Season.Summer => List(YeastType.Lager, YeastType.Wheat, YeastType.Sour)
      case Season.Autumn => List(YeastType.Ale, YeastType.Wild, YeastType.Saison)
      case Season.Winter => List(YeastType.Ale, YeastType.Lager, YeastType.Champagne)
    }
  }

  private def calculateSeasonalScore(yeast: YeastAggregate, season: Season): Double = {
    val baseScore = if (getSeasonalYeastTypes(season).contains(yeast.yeastType)) 0.5 else 0.2
    
    val seasonalBonus = season match {
      case Season.Summer if yeast.characteristics.allCharacteristics.exists(_.toLowerCase.contains("citrus")) => 0.2
      case Season.Winter if yeast.characteristics.allCharacteristics.exists(_.toLowerCase.contains("spic")) => 0.2
      case Season.Autumn if yeast.yeastType == YeastType.Wild => 0.15
      case Season.Spring if yeast.yeastType == YeastType.Saison => 0.15
      case _ => 0.0
    }
    
    baseScore + seasonalBonus
  }

  private def calculateAromaMatchScore(yeast: YeastAggregate, desiredAromas: List[String]): Double = {
    val yeastAromas = yeast.characteristics.allCharacteristics.map(_.toLowerCase)
    val matchingAromas = desiredAromas.count(desired => 
      yeastAromas.exists(_.contains(desired.toLowerCase))
    )
    
    matchingAromas.toDouble / desiredAromas.length
  }

  private def calculateSimilarityScore(original: YeastAggregate, alternative: YeastAggregate): Double = {
    var score = 0.0
    
    if (original.yeastType == alternative.yeastType) score += 0.3
    if (original.laboratory == alternative.laboratory) score += 0.1
    
    // Comparaison plages techniques
    val attenuationOverlap = rangeOverlapPercentage(
      original.attenuation.min, original.attenuation.max,
      alternative.attenuation.min, alternative.attenuation.max
    )
    score += attenuationOverlap * 0.2
    
    val tempOverlap = rangeOverlapPercentage(
      original.temperature.min, original.temperature.max,
      alternative.temperature.min, alternative.temperature.max
    )
    score += tempOverlap * 0.15
    
    if (original.flocculation == alternative.flocculation) score += 0.1
    
    score
  }

  private def rangeOverlapPercentage(min1: Int, max1: Int, min2: Int, max2: Int): Double = {
    val overlapStart = math.max(min1, min2)
    val overlapEnd = math.min(max1, max2)
    val overlap = math.max(0, overlapEnd - overlapStart)
    val totalRange = math.max(max1 - min1, max2 - min2)
    
    if (totalRange == 0) 1.0 else overlap.toDouble / totalRange
  }

  // ==========================================================================
  // GÉNÉRATION DE TEXTES D'AIDE
  // ==========================================================================

  private def generateBeginnerReason(yeast: YeastAggregate): String = {
    s"${yeast.name.value} est idéale pour débuter : ${yeast.flocculation.description.toLowerCase}, ${yeast.characteristics.toString.take(50)}..."
  }

  private def generateBeginnerTips(yeast: YeastAggregate): List[String] = {
    List(
      s"Fermenter à ${yeast.temperature.min}-${yeast.temperature.max}°C",
      s"Atténuation attendue : ${yeast.attenuation.min}-${yeast.attenuation.max}%",
      yeast.flocculation.rackingRecommendation
    )
  }

  private def generateSeasonalReason(yeast: YeastAggregate, season: Season): String = {
    val seasonName = season.toString.toLowerCase
    s"Parfaite pour un brassage de $seasonName avec son profil ${yeast.yeastType.name.toLowerCase}"
  }

  private def generateSeasonalTips(yeast: YeastAggregate, season: Season): List[String] = {
    val baseTips = List(s"Température optimale : ${yeast.temperature}")
    val seasonalTips = season match {
      case Season.Summer => List("Contrôler température fermentation", "Prévoir refroidissement")
      case Season.Winter => List("Laisser atteindre température avant ensemencement")
      case _ => List()
    }
    baseTips ++ seasonalTips
  }

  private def generateExperimentalReason(yeast: YeastAggregate): String = {
    s"${yeast.name.value} offre un profil unique pour l'expérimentation avec ${yeast.characteristics.toString.take(60)}..."
  }

  private def generateExperimentalTips(yeast: YeastAggregate): List[String] = {
    List(
      "Commencer par un petit batch de test",
      "Prévoir fermentation plus longue",
      s"Surveiller température (${yeast.temperature})"
    ) ++ (if (yeast.yeastType == YeastType.Wild) List("Prévoir 3-6 mois minimum") else List())
  }

  private def generateAromaReason(yeast: YeastAggregate, desiredAromas: List[String]): String = {
    val matchingAromas = yeast.characteristics.allCharacteristics
      .filter(c => desiredAromas.exists(d => c.toLowerCase.contains(d.toLowerCase)))
    s"Produit les arômes recherchés : ${matchingAromas.mkString(", ")}"
  }

  private def generateAromaTips(yeast: YeastAggregate): List[String] = {
    List(
      s"Température influence les arômes : ${yeast.temperature}",
      "Contrôler timing dry-hop si IPA",
      "Goûter régulièrement pendant fermentation"
    )
  }

  private def generateAlternativeReason(
    alternative: YeastAggregate, 
    original: YeastAggregate, 
    reason: AlternativeReason
  ): String = {
    val reasonText = reason match {
      case AlternativeReason.Unavailable => "indisponible"
      case AlternativeReason.TooExpensive => "trop chère"
      case AlternativeReason.Experiment => "pour expérimenter"
    }
    s"Alternative à ${original.name.value} ($reasonText) : profil ${alternative.yeastType.name.toLowerCase} similaire"
  }

  private def generateAlternativeTips(alternative: YeastAggregate, original: YeastAggregate): List[String] = {
    List(
      s"Ajuster température si nécessaire : ${alternative.temperature} vs ${original.temperature}",
      s"Atténuation attendue : ${alternative.attenuation} vs ${original.attenuation}",
      "Tester sur petit batch d'abord"
    )
  }

  private def generateTestBatchReason(yeast: YeastAggregate, recipe: TestRecipeParams): String = {
    s"Compatible avec ${recipe.style} : ${yeast.yeastType.name} adapté, température OK"
  }

  private def generateTestBatchTips(yeast: YeastAggregate, recipe: TestRecipeParams): List[String] = {
    List(
      "Batch de 5L recommandé pour test",
      s"Surveiller température : ${recipe.fermentationTemp}°C",
      "Prendre notes détaillées pour comparaison"
    )
  }

  private def calculateTestBatchScore(yeast: YeastAggregate, recipe: TestRecipeParams): Double = {
    var score = 0.0
    
    if (yeast.isCompatibleWith(recipe.style)) score += 0.4
    if (yeast.temperature.contains(recipe.fermentationTemp)) score += 0.3
    if (yeast.alcoholTolerance.canFerment(recipe.expectedAbv)) score += 0.2
    if (yeast.attenuation.contains(recipe.targetAttenuation)) score += 0.1
    
    score
  }
}

// ==========================================================================
// TYPES DE SUPPORT
// ==========================================================================

/**
 * Levure recommandée avec justification
 */
case class RecommendedYeast(
  yeast: YeastAggregate,
  score: Double,
  reason: String,
  tips: List[String]
)

/**
 * Saisons pour recommandations saisonnières
 */
sealed trait Season
object Season {
  case object Spring extends Season
  case object Summer extends Season  
  case object Autumn extends Season
  case object Winter extends Season
}

/**
 * Raisons de recherche d'alternatives
 */
sealed trait AlternativeReason
object AlternativeReason {
  case object Unavailable extends AlternativeReason
  case object TooExpensive extends AlternativeReason
  case object Experiment extends AlternativeReason
}

/**
 * Paramètres de recette pour tests
 */
case class TestRecipeParams(
  style: String,
  fermentationTemp: Int,
  expectedAbv: Double,
  targetAttenuation: Int
)
